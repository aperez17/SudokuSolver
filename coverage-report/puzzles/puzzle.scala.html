<html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title id="title">
          puzzles\puzzle.scala.html
        </title>
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/css/theme.default.min.css" type="text/css"/><script src="http://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/js/jquery.tablesorter.min.js"></script><link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css" type="text/css"/><script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script><script type="text/javascript">
        $(document).ready(function() {$(".tablesorter").tablesorter();});
      </script>
        <style>
          table.codegrid { font-family: monospace; font-size: 12px; width: auto!important; }table.statementlist { width: auto!important; font-size: 13px; } table.codegrid td { padding: 0!important; border: 0!important } table td.linenumber { width: 40px!important; } 
        </style>
      </head>
      <body style="font-family: monospace;">
        <ul class="nav nav-tabs">
          <li>
            <a href="#codegrid" data-toggle="tab">Codegrid</a>
          </li>
          <li>
            <a href="#statementlist" data-toggle="tab">Statement List</a>
          </li>
        </ul>
        <div class="tab-content">
          <div class="tab-pane active" id="codegrid">
            <pre style='font-size: 12pt; font-family: courier;'>1 <span style=''>object Puzzle {
  val EASY = </span><span style='background: #AEF1AE'>"Easy"</span><span style=''>
  val MEDIUM = </span><span style='background: #AEF1AE'>"Medium"</span><span style=''>
  val HARD = </span><span style='background: #AEF1AE'>"hard"</span><span style=''>

  //BELOW HELPER METHODS FOR IMPLEMENTATION

  /**
   * Turns a board to map of the column index to the column
   * i.e.
   * 123456789 <- column index
   * x1xx2xx3x
   * 2x3xx4xx1
   */
  def boardMapToColumns(board: Seq[Seq[Option[Int]]]): Map[Int, Seq[Option[Int]]] = {
    </span><span style='background: #AEF1AE'>board.foldLeft(Map.empty[Int, Seq[Option[Int]]]){ case (boardInColumns, row) =>
      row.foldLeft(boardInColumns) { case (board, columnValueOpt) =>
        val cindex = row.indexOf(columnValueOpt)
        val column = board.getOrElse(cindex, Vector.empty[Option[Int]])
        board + (cindex -> (column :+ columnValueOpt))
      }
    }</span><span style=''>
  }

  /**
   * Turns a board to map of the row index to the column
   * i.e.
   * Index
   * 1  xxx1x2x4
   * 2  xx1x3x5x
   * 3  xxx5x2x9
   * 4  ...
   * 5  ...
   */
  def boardMapToRows(board: Seq[Seq[Option[Int]]]): Map[Int, Seq[Option[Int]]] = {
    </span><span style='background: #F0ADAD'>board.foldLeft(Map.empty[Int, Seq[Option[Int]]]){ case (boardInColumns, row) =>
      val rindex = board.indexOf(row)
      boardInColumns + (rindex -> row)
    }</span><span style=''>
  }

  /**
   * A complete mapping of the index of every row,column to the Option[Int]
   */
  def boardMapToRowsAndColumns(board: Seq[Seq[Option[Int]]]): Map[(Int, Int), Option[Int]] = {
    </span><span style='background: #AEF1AE'>board.foldLeft(Map.empty[(Int,Int), Option[Int]]){ case (map, row) =>
      val rindex = board.indexOf(row)
      row.foldLeft(map) { case (m, numberOpt) =>
        val cindex = board.indexOf(numberOpt)
        map + ((rindex,cindex) -> numberOpt)
      }
    }</span><span style=''>
  }

  /**
   * Maps the board to squares such as
   * (0,0),(0,1),(0,2)
   * (1,0),(1,1),(1,2)
   * (2,0),(2,1),(2,2)
   */
  def boardMapToSquares(board: Seq[Seq[Option[Int]]]): Map[(Int, Int), Seq[Option[Int]]] = {
    val size = </span><span style='background: #AEF1AE'>board.length</span><span style=''>
    val sqrt = </span><span style='background: #AEF1AE'>Math.sqrt(size).toInt</span><span style=''>
    </span><span style='background: #AEF1AE'>board.foldLeft(Map.empty[(Int, Int), Seq[Option[Int]]]) { case (squares, row) =>
      val rindex = board.indexOf(row)
      row.foldLeft(squares) { case (s, numberOpt) =>
        val cindex = row.indexOf(numberOpt)
        val square = s.getOrElse((rindex/sqrt, cindex/sqrt), Vector.empty[Option[Int]])
        s + ((rindex/sqrt, cindex/sqrt) -> (square :+ numberOpt))
      }
    }</span><span style=''>
  }

  /**
   * Turns the board into a 2D array
   */
  def boardTo2DArray(puzzle: Seq[Seq[Option[Int]]]): Array[Array[Option[Int]]] = {
    val board = </span><span style='background: #F0ADAD'>for {
      row <- puzzle
    } yield {
      row.toArray</span><span style=''>
    }
    </span><span style='background: #F0ADAD'>board.toArray</span><span style=''>
  }

  /**
   * Turns board from options to numbers (None =0)
   */
  def convertBoardToNumbers(board: Seq[Seq[Option[Int]]]): Seq[Seq[Int]] = {
    </span><span style='background: #AEF1AE'>board.foldLeft(Seq.empty[Seq[Int]]){ (newBoard, row) =>
      val newRow = row.foldLeft(Seq.empty[Int]) { (nr, numbOpt) =>
        numbOpt match {
          case Some(numb) => nr :+ numb
          case None => nr :+ 0
        }
      }
      newBoard :+ newRow
    }</span><span style=''>
  }


  def boardToSeq(puzzle: Seq[Seq[Option[Int]]]): IndexedSeq[IndexedSeq[Option[Int]]] = {
    val board = </span><span style='background: #AEF1AE'>for {
      row <- puzzle
    } yield {
      row.toIndexedSeq</span><span style=''>
    }
    </span><span style='background: #AEF1AE'>board.toIndexedSeq</span><span style=''>
  }

  /**
   * For debugging use
   */
  def printBoard(name: String, difficulty: Option[String], size: Option[String], board: Seq[Seq[Option[Int]]]) = {
    </span><span style='background: #F0ADAD'>println(name)</span><span style=''>
    </span><span style='background: #F0ADAD'>difficulty.map(println(_))</span><span style=''>
    </span><span style='background: #F0ADAD'>size.map(println(_))</span><span style=''>
    </span><span style='background: #F0ADAD'>for {
      line <- board
    } yield {
      for {
        numb <- line
      } yield {
        numb match {
          case Some(number) => print(s":$number:")
          case None => print(":x:")
        }
      }
      println()
    }</span><span style=''>
  }
}

/**
 * @param name: Name of the puzzle
 * @param difficulty: Difficulty of the puzzle
 * @param size: the size of the board (9x9)
 * @param board: the board we will solve
 */
case class Puzzle(
    name: String,
    difficulty: Option[String] = None,
    size: Option[String] = None,
    board: Seq[Seq[Option[Int]]] = Vector.empty) {

  lazy val sizeFromString: Int = {
    val rowSizeOpt = </span><span style='background: #AEF1AE'>size map(s => s.split("x")(0))</span><span style=''>
    val rowSize = </span><span style='background: #AEF1AE'>rowSizeOpt.getOrElse("9")</span><span style=''>
    </span><span style='background: #AEF1AE'>rowSize.toInt</span><span style=''>
  }

  /**
   * Helper method for validating a number is between the
   * allowed interval (i.e 1-9)
   */
  private def checkNumberIsWithinInterval(number: Int): Boolean = {
    val numbers = </span><span style='background: #AEF1AE'>for {
      i <- 1 to sizeFromString
    } yield {
      i</span><span style=''>
    }
    </span><span style='background: #AEF1AE'>numbers.contains(number)</span><span style=''>
  }

  /**
   * Makes sure that the line does not contain multiple numbers and that
   * all numbers are between the allowed interval, and that the length
   * is the required length
   */
  private def validateLine(line: Seq[Option[Int]], valid: Boolean): Boolean = {
    </span><span style='background: #AEF1AE'>line.foldLeft(valid){ case (v, numberOpt) =>
        numberOpt match {
          case Some(number) =>
            val count = line.filter { numb => numberOpt == numb }.size
            if(count > 1){
              false
            } else {
              if(checkNumberIsWithinInterval(number)){
                v
              } else {
                false
              }
            }
          case None => </span><span style='background: #F0ADAD'>false</span><span style='background: #AEF1AE'>
        }
      } && line.length == sizeFromString</span><span style=''>
  }

  /**
   * Validates that a puzzle is solved correctly
   */
  def validateSolution(puzzleBoard: Seq[Seq[Option[Int]]]): Boolean = {
    </span><span style='background: #AEF1AE'>validateRows(puzzleBoard) && validateColumns(puzzleBoard) && validateSquares(puzzleBoard) && validateInputNumbers(puzzleBoard)</span><span style=''>
  }

  private def validateRows(puzzleBoard: Seq[Seq[Option[Int]]]): Boolean = {
    </span><span style='background: #AEF1AE'>puzzleBoard.foldLeft(true){ case (valid, row) =>
      validateLine(row, valid)
    }</span><span style=''>
  }

  private def validateColumns(puzzleBoard: Seq[Seq[Option[Int]]]): Boolean = {
    val boardMapInColumns = </span><span style='background: #AEF1AE'>Puzzle.boardMapToColumns(puzzleBoard)</span><span style=''>
    </span><span style='background: #AEF1AE'>boardMapInColumns.foldLeft(true) { case (valid, (cindex, column)) =>
      validateLine(column, valid)
    }</span><span style=''>
  }

  private def validateSquares(puzzleBoard: Seq[Seq[Option[Int]]]): Boolean = {
    val squares = </span><span style='background: #AEF1AE'>Puzzle.boardMapToSquares(puzzleBoard)</span><span style=''>
    </span><span style='background: #AEF1AE'>squares.foldLeft(true) { case (valid, (cindex, column)) =>
      validateLine(column, valid)
    }</span><span style=''>
  }

  private def validateInputNumbers(puzzleBoard: Seq[Seq[Option[Int]]]): Boolean = {
    val solutionMap = </span><span style='background: #AEF1AE'>Puzzle.boardMapToRowsAndColumns(puzzleBoard)</span><span style=''>
    val originalMap = </span><span style='background: #AEF1AE'>Puzzle.boardMapToRowsAndColumns(board)</span><span style=''>
    </span><span style='background: #AEF1AE'>solutionMap.keys.foldLeft(true) { case (valid, (rindex, cindex)) =>
      val originalVal = originalMap.getOrElse((rindex,cindex), </span><span style='background: #F0ADAD'>None</span><span style='background: #AEF1AE'>)
      if(originalVal.nonEmpty){
        val solutionVal = solutionMap.getOrElse((rindex,cindex), </span><span style='background: #F0ADAD'>None</span><span style='background: #AEF1AE'>)
        if(solutionVal == originalVal){
          valid
        } else {
          false
        }
      } else {
        valid
      }
    }</span><span style=''>
  }
}

</span></pre>
          </div>
          <div class="tab-pane" id="statementlist">
            <table cellspacing="0" cellpadding="0" class="table statementlist">
      <tr>
        <th>Line</th>
        <th>Stmt Id</th>
        <th>Pos</th>
        <th>Tree</th>
        <th>Symbol</th>
        <th>Code</th>
      </tr><tr>
        <td>
          2
        </td>
        <td>
          684
        </td>
        <td>
          29
          -
          35
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          &quot;Easy&quot;
        </td>
      </tr><tr>
        <td>
          3
        </td>
        <td>
          685
        </td>
        <td>
          51
          -
          59
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          &quot;Medium&quot;
        </td>
      </tr><tr>
        <td>
          4
        </td>
        <td>
          686
        </td>
        <td>
          73
          -
          79
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          &quot;hard&quot;
        </td>
      </tr><tr>
        <td>
          16
        </td>
        <td>
          687
        </td>
        <td>
          374
          -
          406
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.Map.empty
        </td>
        <td style="background: #AEF1AE">
          scala.this.Predef.Map.empty[Int, Seq[Option[Int]]]
        </td>
      </tr><tr>
        <td>
          16
        </td>
        <td>
          696
        </td>
        <td>
          359
          -
          697
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.foldLeft
        </td>
        <td style="background: #AEF1AE">
          board.foldLeft[scala.collection.immutable.Map[Int,Seq[Option[Int]]]](scala.this.Predef.Map.empty[Int, Seq[Option[Int]]])(((x0$1: scala.collection.immutable.Map[Int,Seq[Option[Int]]], x1$1: Seq[Option[Int]]) =&gt; scala.Tuple2.apply[scala.collection.immutable.Map[Int,Seq[Option[Int]]], Seq[Option[Int]]](x0$1, x1$1) match {
  case (_1: scala.collection.immutable.Map[Int,Seq[Option[Int]]], _2: Seq[Option[Int]])(scala.collection.immutable.Map[Int,Seq[Option[Int]]], Seq[Option[Int]])((boardInColumns @ _), (row @ _)) =&gt; row.foldLeft[scala.collection.immutable.Map[Int,Seq[Option[Int]]]](boardInColumns)(((x0$2: scala.collection.immutable.Map[Int,Seq[Option[Int]]], x1$2: Option[Int]) =&gt; scala.Tuple2.apply[scala.collection.immutable.Map[Int,Seq[Option[Int]]], Option[Int]](x0$2, x1$2) match {
    case (_1: scala.collection.immutable.Map[Int,Seq[Option[Int]]], _2: Option[Int])(scala.collection.immutable.Map[Int,Seq[Option[Int]]], Option[Int])((board @ _), (columnValueOpt @ _)) =&gt; {
      val cindex: Int = row.indexOf[Option[Int]](columnValueOpt);
      val column: Seq[Option[Int]] = board.getOrElse[Seq[Option[Int]]](cindex, scala.`package`.Vector.empty[Option[Int]]);
      board.+[Seq[Option[Int]]](scala.this.Predef.ArrowAssoc[Int](cindex).-&gt;[Seq[Option[Int]]](column.:+[Option[Int], Seq[Option[Int]]](columnValueOpt)(collection.this.Seq.canBuildFrom[Option[Int]])))
    }
  }))
}))
        </td>
      </tr><tr>
        <td>
          17
        </td>
        <td>
          695
        </td>
        <td>
          445
          -
          691
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.foldLeft
        </td>
        <td style="background: #AEF1AE">
          row.foldLeft[scala.collection.immutable.Map[Int,Seq[Option[Int]]]](boardInColumns)(((x0$2: scala.collection.immutable.Map[Int,Seq[Option[Int]]], x1$2: Option[Int]) =&gt; scala.Tuple2.apply[scala.collection.immutable.Map[Int,Seq[Option[Int]]], Option[Int]](x0$2, x1$2) match {
  case (_1: scala.collection.immutable.Map[Int,Seq[Option[Int]]], _2: Option[Int])(scala.collection.immutable.Map[Int,Seq[Option[Int]]], Option[Int])((board @ _), (columnValueOpt @ _)) =&gt; {
    val cindex: Int = row.indexOf[Option[Int]](columnValueOpt);
    val column: Seq[Option[Int]] = board.getOrElse[Seq[Option[Int]]](cindex, scala.`package`.Vector.empty[Option[Int]]);
    board.+[Seq[Option[Int]]](scala.this.Predef.ArrowAssoc[Int](cindex).-&gt;[Seq[Option[Int]]](column.:+[Option[Int], Seq[Option[Int]]](columnValueOpt)(collection.this.Seq.canBuildFrom[Option[Int]])))
  }
}))
        </td>
      </tr><tr>
        <td>
          18
        </td>
        <td>
          688
        </td>
        <td>
          529
          -
          556
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.GenSeqLike.indexOf
        </td>
        <td style="background: #AEF1AE">
          row.indexOf[Option[Int]](columnValueOpt)
        </td>
      </tr><tr>
        <td>
          19
        </td>
        <td>
          690
        </td>
        <td>
          578
          -
          628
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.MapLike.getOrElse
        </td>
        <td style="background: #AEF1AE">
          board.getOrElse[Seq[Option[Int]]](cindex, scala.`package`.Vector.empty[Option[Int]])
        </td>
      </tr><tr>
        <td>
          19
        </td>
        <td>
          689
        </td>
        <td>
          602
          -
          627
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.Vector.empty
        </td>
        <td style="background: #AEF1AE">
          scala.`package`.Vector.empty[Option[Int]]
        </td>
      </tr><tr>
        <td>
          20
        </td>
        <td>
          693
        </td>
        <td>
          646
          -
          682
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.ArrowAssoc.-&gt;
        </td>
        <td style="background: #AEF1AE">
          scala.this.Predef.ArrowAssoc[Int](cindex).-&gt;[Seq[Option[Int]]](column.:+[Option[Int], Seq[Option[Int]]](columnValueOpt)(collection.this.Seq.canBuildFrom[Option[Int]]))
        </td>
      </tr><tr>
        <td>
          20
        </td>
        <td>
          692
        </td>
        <td>
          657
          -
          681
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.SeqLike.:+
        </td>
        <td style="background: #AEF1AE">
          column.:+[Option[Int], Seq[Option[Int]]](columnValueOpt)(collection.this.Seq.canBuildFrom[Option[Int]])
        </td>
      </tr><tr>
        <td>
          20
        </td>
        <td>
          691
        </td>
        <td>
          664
          -
          664
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Option[Int]]
        </td>
      </tr><tr>
        <td>
          20
        </td>
        <td>
          694
        </td>
        <td>
          637
          -
          683
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.immutable.Map.+
        </td>
        <td style="background: #AEF1AE">
          board.+[Seq[Option[Int]]](scala.this.Predef.ArrowAssoc[Int](cindex).-&gt;[Seq[Option[Int]]](column.:+[Option[Int], Seq[Option[Int]]](columnValueOpt)(collection.this.Seq.canBuildFrom[Option[Int]])))
        </td>
      </tr><tr>
        <td>
          36
        </td>
        <td>
          701
        </td>
        <td>
          955
          -
          1117
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.foldLeft
        </td>
        <td style="background: #F0ADAD">
          board.foldLeft[scala.collection.immutable.Map[Int,Seq[Option[Int]]]](scala.this.Predef.Map.empty[Int, Seq[Option[Int]]])(((x0$3: scala.collection.immutable.Map[Int,Seq[Option[Int]]], x1$3: Seq[Option[Int]]) =&gt; scala.Tuple2.apply[scala.collection.immutable.Map[Int,Seq[Option[Int]]], Seq[Option[Int]]](x0$3, x1$3) match {
  case (_1: scala.collection.immutable.Map[Int,Seq[Option[Int]]], _2: Seq[Option[Int]])(scala.collection.immutable.Map[Int,Seq[Option[Int]]], Seq[Option[Int]])((boardInColumns @ _), (row @ _)) =&gt; {
    val rindex: Int = board.indexOf[Seq[Option[Int]]](row);
    boardInColumns.+[Seq[Option[Int]]](scala.this.Predef.ArrowAssoc[Int](rindex).-&gt;[Seq[Option[Int]]](row))
  }
}))
        </td>
      </tr><tr>
        <td>
          36
        </td>
        <td>
          697
        </td>
        <td>
          970
          -
          1002
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.Map.empty
        </td>
        <td style="background: #F0ADAD">
          scala.this.Predef.Map.empty[Int, Seq[Option[Int]]]
        </td>
      </tr><tr>
        <td>
          37
        </td>
        <td>
          698
        </td>
        <td>
          1054
          -
          1072
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.GenSeqLike.indexOf
        </td>
        <td style="background: #F0ADAD">
          board.indexOf[Seq[Option[Int]]](row)
        </td>
      </tr><tr>
        <td>
          38
        </td>
        <td>
          699
        </td>
        <td>
          1097
          -
          1110
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.ArrowAssoc.-&gt;
        </td>
        <td style="background: #F0ADAD">
          scala.this.Predef.ArrowAssoc[Int](rindex).-&gt;[Seq[Option[Int]]](row)
        </td>
      </tr><tr>
        <td>
          38
        </td>
        <td>
          700
        </td>
        <td>
          1079
          -
          1111
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.immutable.Map.+
        </td>
        <td style="background: #F0ADAD">
          boardInColumns.+[Seq[Option[Int]]](scala.this.Predef.ArrowAssoc[Int](rindex).-&gt;[Seq[Option[Int]]](row))
        </td>
      </tr><tr>
        <td>
          46
        </td>
        <td>
          708
        </td>
        <td>
          1310
          -
          1571
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.foldLeft
        </td>
        <td style="background: #AEF1AE">
          board.foldLeft[scala.collection.immutable.Map[(Int, Int),Option[Int]]](scala.this.Predef.Map.empty[(Int, Int), Option[Int]])(((x0$4: scala.collection.immutable.Map[(Int, Int),Option[Int]], x1$4: Seq[Option[Int]]) =&gt; scala.Tuple2.apply[scala.collection.immutable.Map[(Int, Int),Option[Int]], Seq[Option[Int]]](x0$4, x1$4) match {
  case (_1: scala.collection.immutable.Map[(Int, Int),Option[Int]], _2: Seq[Option[Int]])(scala.collection.immutable.Map[(Int, Int),Option[Int]], Seq[Option[Int]])((map @ _), (row @ _)) =&gt; {
    val rindex: Int = board.indexOf[Seq[Option[Int]]](row);
    row.foldLeft[scala.collection.immutable.Map[(Int, Int),Option[Int]]](map)(((x0$5: scala.collection.immutable.Map[(Int, Int),Option[Int]], x1$5: Option[Int]) =&gt; scala.Tuple2.apply[scala.collection.immutable.Map[(Int, Int),Option[Int]], Option[Int]](x0$5, x1$5) match {
      case (_1: scala.collection.immutable.Map[(Int, Int),Option[Int]], _2: Option[Int])(scala.collection.immutable.Map[(Int, Int),Option[Int]], Option[Int])((m @ _), (numberOpt @ _)) =&gt; {
        val cindex: Int = board.indexOf[Equals](numberOpt);
        map.+[Option[Int]](scala.this.Predef.ArrowAssoc[(Int, Int)](scala.Tuple2.apply[Int, Int](rindex, cindex)).-&gt;[Option[Int]](numberOpt))
      }
    }))
  }
}))
        </td>
      </tr><tr>
        <td>
          46
        </td>
        <td>
          702
        </td>
        <td>
          1325
          -
          1358
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.Map.empty
        </td>
        <td style="background: #AEF1AE">
          scala.this.Predef.Map.empty[(Int, Int), Option[Int]]
        </td>
      </tr><tr>
        <td>
          47
        </td>
        <td>
          703
        </td>
        <td>
          1399
          -
          1417
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.GenSeqLike.indexOf
        </td>
        <td style="background: #AEF1AE">
          board.indexOf[Seq[Option[Int]]](row)
        </td>
      </tr><tr>
        <td>
          48
        </td>
        <td>
          707
        </td>
        <td>
          1424
          -
          1565
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.foldLeft
        </td>
        <td style="background: #AEF1AE">
          row.foldLeft[scala.collection.immutable.Map[(Int, Int),Option[Int]]](map)(((x0$5: scala.collection.immutable.Map[(Int, Int),Option[Int]], x1$5: Option[Int]) =&gt; scala.Tuple2.apply[scala.collection.immutable.Map[(Int, Int),Option[Int]], Option[Int]](x0$5, x1$5) match {
  case (_1: scala.collection.immutable.Map[(Int, Int),Option[Int]], _2: Option[Int])(scala.collection.immutable.Map[(Int, Int),Option[Int]], Option[Int])((m @ _), (numberOpt @ _)) =&gt; {
    val cindex: Int = board.indexOf[Equals](numberOpt);
    map.+[Option[Int]](scala.this.Predef.ArrowAssoc[(Int, Int)](scala.Tuple2.apply[Int, Int](rindex, cindex)).-&gt;[Option[Int]](numberOpt))
  }
}))
        </td>
      </tr><tr>
        <td>
          49
        </td>
        <td>
          704
        </td>
        <td>
          1488
          -
          1512
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.GenSeqLike.indexOf
        </td>
        <td style="background: #AEF1AE">
          board.indexOf[Equals](numberOpt)
        </td>
      </tr><tr>
        <td>
          50
        </td>
        <td>
          705
        </td>
        <td>
          1528
          -
          1556
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.ArrowAssoc.-&gt;
        </td>
        <td style="background: #AEF1AE">
          scala.this.Predef.ArrowAssoc[(Int, Int)](scala.Tuple2.apply[Int, Int](rindex, cindex)).-&gt;[Option[Int]](numberOpt)
        </td>
      </tr><tr>
        <td>
          50
        </td>
        <td>
          706
        </td>
        <td>
          1521
          -
          1557
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.immutable.Map.+
        </td>
        <td style="background: #AEF1AE">
          map.+[Option[Int]](scala.this.Predef.ArrowAssoc[(Int, Int)](scala.Tuple2.apply[Int, Int](rindex, cindex)).-&gt;[Option[Int]](numberOpt))
        </td>
      </tr><tr>
        <td>
          62
        </td>
        <td>
          709
        </td>
        <td>
          1805
          -
          1817
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SeqLike.length
        </td>
        <td style="background: #AEF1AE">
          board.length
        </td>
      </tr><tr>
        <td>
          63
        </td>
        <td>
          711
        </td>
        <td>
          1833
          -
          1854
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Double.toInt
        </td>
        <td style="background: #AEF1AE">
          java.this.lang.Math.sqrt(size.toDouble).toInt
        </td>
      </tr><tr>
        <td>
          63
        </td>
        <td>
          710
        </td>
        <td>
          1843
          -
          1847
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Int.toDouble
        </td>
        <td style="background: #AEF1AE">
          size.toDouble
        </td>
      </tr><tr>
        <td>
          64
        </td>
        <td>
          728
        </td>
        <td>
          1859
          -
          2242
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.foldLeft
        </td>
        <td style="background: #AEF1AE">
          board.foldLeft[scala.collection.immutable.Map[(Int, Int),Seq[Option[Int]]]](scala.this.Predef.Map.empty[(Int, Int), Seq[Option[Int]]])(((x0$6: scala.collection.immutable.Map[(Int, Int),Seq[Option[Int]]], x1$6: Seq[Option[Int]]) =&gt; scala.Tuple2.apply[scala.collection.immutable.Map[(Int, Int),Seq[Option[Int]]], Seq[Option[Int]]](x0$6, x1$6) match {
  case (_1: scala.collection.immutable.Map[(Int, Int),Seq[Option[Int]]], _2: Seq[Option[Int]])(scala.collection.immutable.Map[(Int, Int),Seq[Option[Int]]], Seq[Option[Int]])((squares @ _), (row @ _)) =&gt; {
    val rindex: Int = board.indexOf[Seq[Option[Int]]](row);
    row.foldLeft[scala.collection.immutable.Map[(Int, Int),Seq[Option[Int]]]](squares)(((x0$7: scala.collection.immutable.Map[(Int, Int),Seq[Option[Int]]], x1$7: Option[Int]) =&gt; scala.Tuple2.apply[scala.collection.immutable.Map[(Int, Int),Seq[Option[Int]]], Option[Int]](x0$7, x1$7) match {
      case (_1: scala.collection.immutable.Map[(Int, Int),Seq[Option[Int]]], _2: Option[Int])(scala.collection.immutable.Map[(Int, Int),Seq[Option[Int]]], Option[Int])((s @ _), (numberOpt @ _)) =&gt; {
        val cindex: Int = row.indexOf[Option[Int]](numberOpt);
        val square: Seq[Option[Int]] = s.getOrElse[Seq[Option[Int]]](scala.Tuple2.apply[Int, Int](rindex./(sqrt), cindex./(sqrt)), scala.`package`.Vector.empty[Option[Int]]);
        s.+[Seq[Option[Int]]](scala.this.Predef.ArrowAssoc[(Int, Int)](scala.Tuple2.apply[Int, Int](rindex./(sqrt), cindex./(sqrt))).-&gt;[Seq[Option[Int]]](square.:+[Option[Int], Seq[Option[Int]]](numberOpt)(collection.this.Seq.canBuildFrom[Option[Int]])))
      }
    }))
  }
}))
        </td>
      </tr><tr>
        <td>
          64
        </td>
        <td>
          712
        </td>
        <td>
          1874
          -
          1913
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.Map.empty
        </td>
        <td style="background: #AEF1AE">
          scala.this.Predef.Map.empty[(Int, Int), Seq[Option[Int]]]
        </td>
      </tr><tr>
        <td>
          65
        </td>
        <td>
          713
        </td>
        <td>
          1959
          -
          1977
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.GenSeqLike.indexOf
        </td>
        <td style="background: #AEF1AE">
          board.indexOf[Seq[Option[Int]]](row)
        </td>
      </tr><tr>
        <td>
          66
        </td>
        <td>
          727
        </td>
        <td>
          1984
          -
          2236
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.foldLeft
        </td>
        <td style="background: #AEF1AE">
          row.foldLeft[scala.collection.immutable.Map[(Int, Int),Seq[Option[Int]]]](squares)(((x0$7: scala.collection.immutable.Map[(Int, Int),Seq[Option[Int]]], x1$7: Option[Int]) =&gt; scala.Tuple2.apply[scala.collection.immutable.Map[(Int, Int),Seq[Option[Int]]], Option[Int]](x0$7, x1$7) match {
  case (_1: scala.collection.immutable.Map[(Int, Int),Seq[Option[Int]]], _2: Option[Int])(scala.collection.immutable.Map[(Int, Int),Seq[Option[Int]]], Option[Int])((s @ _), (numberOpt @ _)) =&gt; {
    val cindex: Int = row.indexOf[Option[Int]](numberOpt);
    val square: Seq[Option[Int]] = s.getOrElse[Seq[Option[Int]]](scala.Tuple2.apply[Int, Int](rindex./(sqrt), cindex./(sqrt)), scala.`package`.Vector.empty[Option[Int]]);
    s.+[Seq[Option[Int]]](scala.this.Predef.ArrowAssoc[(Int, Int)](scala.Tuple2.apply[Int, Int](rindex./(sqrt), cindex./(sqrt))).-&gt;[Seq[Option[Int]]](square.:+[Option[Int], Seq[Option[Int]]](numberOpt)(collection.this.Seq.canBuildFrom[Option[Int]])))
  }
}))
        </td>
      </tr><tr>
        <td>
          67
        </td>
        <td>
          714
        </td>
        <td>
          2052
          -
          2074
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.GenSeqLike.indexOf
        </td>
        <td style="background: #AEF1AE">
          row.indexOf[Option[Int]](numberOpt)
        </td>
      </tr><tr>
        <td>
          68
        </td>
        <td>
          717
        </td>
        <td>
          2108
          -
          2134
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Int, Int](rindex./(sqrt), cindex./(sqrt))
        </td>
      </tr><tr>
        <td>
          68
        </td>
        <td>
          719
        </td>
        <td>
          2096
          -
          2162
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.MapLike.getOrElse
        </td>
        <td style="background: #AEF1AE">
          s.getOrElse[Seq[Option[Int]]](scala.Tuple2.apply[Int, Int](rindex./(sqrt), cindex./(sqrt)), scala.`package`.Vector.empty[Option[Int]])
        </td>
      </tr><tr>
        <td>
          68
        </td>
        <td>
          716
        </td>
        <td>
          2122
          -
          2133
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int./
        </td>
        <td style="background: #AEF1AE">
          cindex./(sqrt)
        </td>
      </tr><tr>
        <td>
          68
        </td>
        <td>
          715
        </td>
        <td>
          2109
          -
          2120
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int./
        </td>
        <td style="background: #AEF1AE">
          rindex./(sqrt)
        </td>
      </tr><tr>
        <td>
          68
        </td>
        <td>
          718
        </td>
        <td>
          2136
          -
          2161
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.Vector.empty
        </td>
        <td style="background: #AEF1AE">
          scala.`package`.Vector.empty[Option[Int]]
        </td>
      </tr><tr>
        <td>
          69
        </td>
        <td>
          720
        </td>
        <td>
          2177
          -
          2188
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int./
        </td>
        <td style="background: #AEF1AE">
          rindex./(sqrt)
        </td>
      </tr><tr>
        <td>
          69
        </td>
        <td>
          723
        </td>
        <td>
          2214
          -
          2214
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Option[Int]]
        </td>
      </tr><tr>
        <td>
          69
        </td>
        <td>
          726
        </td>
        <td>
          2171
          -
          2228
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.immutable.Map.+
        </td>
        <td style="background: #AEF1AE">
          s.+[Seq[Option[Int]]](scala.this.Predef.ArrowAssoc[(Int, Int)](scala.Tuple2.apply[Int, Int](rindex./(sqrt), cindex./(sqrt))).-&gt;[Seq[Option[Int]]](square.:+[Option[Int], Seq[Option[Int]]](numberOpt)(collection.this.Seq.canBuildFrom[Option[Int]])))
        </td>
      </tr><tr>
        <td>
          69
        </td>
        <td>
          722
        </td>
        <td>
          2176
          -
          2202
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Int, Int](rindex./(sqrt), cindex./(sqrt))
        </td>
      </tr><tr>
        <td>
          69
        </td>
        <td>
          725
        </td>
        <td>
          2176
          -
          2227
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.ArrowAssoc.-&gt;
        </td>
        <td style="background: #AEF1AE">
          scala.this.Predef.ArrowAssoc[(Int, Int)](scala.Tuple2.apply[Int, Int](rindex./(sqrt), cindex./(sqrt))).-&gt;[Seq[Option[Int]]](square.:+[Option[Int], Seq[Option[Int]]](numberOpt)(collection.this.Seq.canBuildFrom[Option[Int]]))
        </td>
      </tr><tr>
        <td>
          69
        </td>
        <td>
          724
        </td>
        <td>
          2207
          -
          2226
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.SeqLike.:+
        </td>
        <td style="background: #AEF1AE">
          square.:+[Option[Int], Seq[Option[Int]]](numberOpt)(collection.this.Seq.canBuildFrom[Option[Int]])
        </td>
      </tr><tr>
        <td>
          69
        </td>
        <td>
          721
        </td>
        <td>
          2190
          -
          2201
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int./
        </td>
        <td style="background: #AEF1AE">
          cindex./(sqrt)
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          731
        </td>
        <td>
          2396
          -
          2453
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td style="background: #F0ADAD">
          puzzle.map[Array[Option[Int]], Seq[Array[Option[Int]]]](((row: Seq[Option[Int]]) =&gt; row.toArray[Option[Int]]((ClassTag.apply[Option[Int]](classOf[scala.Option]): scala.reflect.ClassTag[Option[Int]]))))(collection.this.Seq.canBuildFrom[Array[Option[Int]]])
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          730
        </td>
        <td>
          2412
          -
          2412
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td style="background: #F0ADAD">
          collection.this.Seq.canBuildFrom[Array[Option[Int]]]
        </td>
      </tr><tr>
        <td>
          81
        </td>
        <td>
          729
        </td>
        <td>
          2442
          -
          2453
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.toArray
        </td>
        <td style="background: #F0ADAD">
          row.toArray[Option[Int]]((ClassTag.apply[Option[Int]](classOf[scala.Option]): scala.reflect.ClassTag[Option[Int]]))
        </td>
      </tr><tr>
        <td>
          83
        </td>
        <td>
          732
        </td>
        <td>
          2464
          -
          2477
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.toArray
        </td>
        <td style="background: #F0ADAD">
          board.toArray[Array[Option[Int]]]((ClassTag.apply[Array[Option[Int]]](ScalaRunTime.this.arrayClass(classOf[scala.Option])): scala.reflect.ClassTag[Array[Option[Int]]]))
        </td>
      </tr><tr>
        <td>
          90
        </td>
        <td>
          743
        </td>
        <td>
          2627
          -
          2893
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.foldLeft
        </td>
        <td style="background: #AEF1AE">
          board.foldLeft[Seq[Seq[Int]]](collection.this.Seq.empty[Seq[Int]])(((newBoard: Seq[Seq[Int]], row: Seq[Option[Int]]) =&gt; {
  val newRow: Seq[Int] = row.foldLeft[Seq[Int]](collection.this.Seq.empty[Int])(((nr: Seq[Int], numbOpt: Option[Int]) =&gt; numbOpt match {
    case (x: Int)Some[Int]((numb @ _)) =&gt; nr.:+[Int, Seq[Int]](numb)(collection.this.Seq.canBuildFrom[Int])
    case scala.None =&gt; nr.:+[Int, Seq[Int]](0)(collection.this.Seq.canBuildFrom[Int])
  }));
  newBoard.:+[Seq[Int], Seq[Seq[Int]]](newRow)(collection.this.Seq.canBuildFrom[Seq[Int]])
}))
        </td>
      </tr><tr>
        <td>
          90
        </td>
        <td>
          733
        </td>
        <td>
          2642
          -
          2661
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.empty
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.empty[Seq[Int]]
        </td>
      </tr><tr>
        <td>
          91
        </td>
        <td>
          740
        </td>
        <td>
          2702
          -
          2862
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.foldLeft
        </td>
        <td style="background: #AEF1AE">
          row.foldLeft[Seq[Int]](collection.this.Seq.empty[Int])(((nr: Seq[Int], numbOpt: Option[Int]) =&gt; numbOpt match {
  case (x: Int)Some[Int]((numb @ _)) =&gt; nr.:+[Int, Seq[Int]](numb)(collection.this.Seq.canBuildFrom[Int])
  case scala.None =&gt; nr.:+[Int, Seq[Int]](0)(collection.this.Seq.canBuildFrom[Int])
}))
        </td>
      </tr><tr>
        <td>
          91
        </td>
        <td>
          734
        </td>
        <td>
          2715
          -
          2729
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.empty
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.empty[Int]
        </td>
      </tr><tr>
        <td>
          93
        </td>
        <td>
          735
        </td>
        <td>
          2806
          -
          2806
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          93
        </td>
        <td>
          736
        </td>
        <td>
          2803
          -
          2813
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.SeqLike.:+
        </td>
        <td style="background: #AEF1AE">
          nr.:+[Int, Seq[Int]](numb)(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          94
        </td>
        <td>
          738
        </td>
        <td>
          2840
          -
          2840
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          94
        </td>
        <td>
          737
        </td>
        <td>
          2843
          -
          2844
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          94
        </td>
        <td>
          739
        </td>
        <td>
          2837
          -
          2844
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.SeqLike.:+
        </td>
        <td style="background: #AEF1AE">
          nr.:+[Int, Seq[Int]](0)(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          741
        </td>
        <td>
          2878
          -
          2878
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Seq[Int]]
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          742
        </td>
        <td>
          2869
          -
          2887
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.SeqLike.:+
        </td>
        <td style="background: #AEF1AE">
          newBoard.:+[Seq[Int], Seq[Seq[Int]]](newRow)(collection.this.Seq.canBuildFrom[Seq[Int]])
        </td>
      </tr><tr>
        <td>
          104
        </td>
        <td>
          746
        </td>
        <td>
          3005
          -
          3067
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td style="background: #AEF1AE">
          puzzle.map[scala.collection.immutable.IndexedSeq[Option[Int]], Seq[scala.collection.immutable.IndexedSeq[Option[Int]]]](((row: Seq[Option[Int]]) =&gt; row.toIndexedSeq))(collection.this.Seq.canBuildFrom[scala.collection.immutable.IndexedSeq[Option[Int]]])
        </td>
      </tr><tr>
        <td>
          104
        </td>
        <td>
          745
        </td>
        <td>
          3021
          -
          3021
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[scala.collection.immutable.IndexedSeq[Option[Int]]]
        </td>
      </tr><tr>
        <td>
          106
        </td>
        <td>
          744
        </td>
        <td>
          3051
          -
          3067
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.TraversableOnce.toIndexedSeq
        </td>
        <td style="background: #AEF1AE">
          row.toIndexedSeq
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          747
        </td>
        <td>
          3078
          -
          3096
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.TraversableOnce.toIndexedSeq
        </td>
        <td style="background: #AEF1AE">
          board.toIndexedSeq
        </td>
      </tr><tr>
        <td>
          115
        </td>
        <td>
          748
        </td>
        <td>
          3256
          -
          3269
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.println
        </td>
        <td style="background: #F0ADAD">
          scala.this.Predef.println(name)
        </td>
      </tr><tr>
        <td>
          116
        </td>
        <td>
          750
        </td>
        <td>
          3274
          -
          3300
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td style="background: #F0ADAD">
          difficulty.map[Unit](((x$1: String) =&gt; scala.this.Predef.println(x$1)))
        </td>
      </tr><tr>
        <td>
          116
        </td>
        <td>
          749
        </td>
        <td>
          3289
          -
          3299
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.println
        </td>
        <td style="background: #F0ADAD">
          scala.this.Predef.println(x$1)
        </td>
      </tr><tr>
        <td>
          117
        </td>
        <td>
          752
        </td>
        <td>
          3305
          -
          3325
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td style="background: #F0ADAD">
          size.map[Unit](((x$2: String) =&gt; scala.this.Predef.println(x$2)))
        </td>
      </tr><tr>
        <td>
          117
        </td>
        <td>
          751
        </td>
        <td>
          3314
          -
          3324
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.println
        </td>
        <td style="background: #F0ADAD">
          scala.this.Predef.println(x$2)
        </td>
      </tr><tr>
        <td>
          119
        </td>
        <td>
          759
        </td>
        <td>
          3347
          -
          3347
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td style="background: #F0ADAD">
          collection.this.Seq.canBuildFrom[Unit]
        </td>
      </tr><tr>
        <td>
          119
        </td>
        <td>
          760
        </td>
        <td>
          3330
          -
          3566
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td style="background: #F0ADAD">
          board.map[Unit, Seq[Unit]](((line: Seq[Option[Int]]) =&gt; {
  line.map[Unit, Seq[Unit]](((numb: Option[Int]) =&gt; numb match {
    case (x: Int)Some[Int]((number @ _)) =&gt; scala.this.Predef.print(scala.StringContext.apply(&quot;:&quot;, &quot;:&quot;).s(number))
    case scala.None =&gt; scala.this.Predef.print(&quot;:x:&quot;)
  }))(collection.this.Seq.canBuildFrom[Unit]);
  scala.this.Predef.println()
}))(collection.this.Seq.canBuildFrom[Unit])
        </td>
      </tr><tr>
        <td>
          122
        </td>
        <td>
          756
        </td>
        <td>
          3395
          -
          3395
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td style="background: #F0ADAD">
          collection.this.Seq.canBuildFrom[Unit]
        </td>
      </tr><tr>
        <td>
          122
        </td>
        <td>
          757
        </td>
        <td>
          3376
          -
          3536
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td style="background: #F0ADAD">
          line.map[Unit, Seq[Unit]](((numb: Option[Int]) =&gt; numb match {
  case (x: Int)Some[Int]((number @ _)) =&gt; scala.this.Predef.print(scala.StringContext.apply(&quot;:&quot;, &quot;:&quot;).s(number))
  case scala.None =&gt; scala.this.Predef.print(&quot;:x:&quot;)
}))(collection.this.Seq.canBuildFrom[Unit])
        </td>
      </tr><tr>
        <td>
          125
        </td>
        <td>
          753
        </td>
        <td>
          3477
          -
          3489
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.StringContext.s
        </td>
        <td style="background: #F0ADAD">
          scala.StringContext.apply(&quot;:&quot;, &quot;:&quot;).s(number)
        </td>
      </tr><tr>
        <td>
          125
        </td>
        <td>
          754
        </td>
        <td>
          3471
          -
          3490
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.print
        </td>
        <td style="background: #F0ADAD">
          scala.this.Predef.print(scala.StringContext.apply(&quot;:&quot;, &quot;:&quot;).s(number))
        </td>
      </tr><tr>
        <td>
          126
        </td>
        <td>
          755
        </td>
        <td>
          3514
          -
          3526
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.print
        </td>
        <td style="background: #F0ADAD">
          scala.this.Predef.print(&quot;:x:&quot;)
        </td>
      </tr><tr>
        <td>
          129
        </td>
        <td>
          758
        </td>
        <td>
          3551
          -
          3560
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.println
        </td>
        <td style="background: #F0ADAD">
          scala.this.Predef.println()
        </td>
      </tr><tr>
        <td>
          147
        </td>
        <td>
          762
        </td>
        <td>
          3966
          -
          3996
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td style="background: #AEF1AE">
          Puzzle.this.size.map[String](((s: String) =&gt; s.split(&quot;x&quot;).apply(0)))
        </td>
      </tr><tr>
        <td>
          147
        </td>
        <td>
          761
        </td>
        <td>
          3980
          -
          3995
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Array.apply
        </td>
        <td style="background: #AEF1AE">
          s.split(&quot;x&quot;).apply(0)
        </td>
      </tr><tr>
        <td>
          148
        </td>
        <td>
          763
        </td>
        <td>
          4015
          -
          4040
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td style="background: #AEF1AE">
          rowSizeOpt.getOrElse[String](&quot;9&quot;)
        </td>
      </tr><tr>
        <td>
          149
        </td>
        <td>
          764
        </td>
        <td>
          4045
          -
          4058
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.immutable.StringLike.toInt
        </td>
        <td style="background: #AEF1AE">
          scala.this.Predef.augmentString(rowSize).toInt
        </td>
      </tr><tr>
        <td>
          158
        </td>
        <td>
          765
        </td>
        <td>
          4269
          -
          4270
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          1
        </td>
      </tr><tr>
        <td>
          158
        </td>
        <td>
          767
        </td>
        <td>
          4252
          -
          4310
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td style="background: #AEF1AE">
          scala.this.Predef.intWrapper(1).to(Puzzle.this.sizeFromString).map[Int, scala.collection.immutable.IndexedSeq[Int]](((i: Int) =&gt; i))(immutable.this.IndexedSeq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          158
        </td>
        <td>
          766
        </td>
        <td>
          4266
          -
          4266
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.IndexedSeq.canBuildFrom
        </td>
        <td style="background: #AEF1AE">
          immutable.this.IndexedSeq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          768
        </td>
        <td>
          4321
          -
          4345
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.SeqLike.contains
        </td>
        <td style="background: #AEF1AE">
          numbers.contains[Int](number)
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          770
        </td>
        <td>
          4745
          -
          4791
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SeqLike.size
        </td>
        <td style="background: #AEF1AE">
          line.filter(((numb: Option[Int]) =&gt; numberOpt.==(numb))).size
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          769
        </td>
        <td>
          4767
          -
          4784
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td style="background: #AEF1AE">
          numberOpt.==(numb)
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          771
        </td>
        <td>
          4807
          -
          4816
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&gt;
        </td>
        <td style="background: #AEF1AE">
          count.&gt;(1)
        </td>
      </tr><tr>
        <td>
          176
        </td>
        <td>
          773
        </td>
        <td>
          4833
          -
          4838
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          false
        </td>
      </tr><tr>
        <td>
          176
        </td>
        <td>
          772
        </td>
        <td>
          4833
          -
          4838
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          false
        </td>
      </tr><tr>
        <td>
          178
        </td>
        <td>
          774
        </td>
        <td>
          4877
          -
          4912
        </td>
        <td>
          Apply
        </td>
        <td>
          Puzzle.checkNumberIsWithinInterval
        </td>
        <td style="background: #AEF1AE">
          Puzzle.this.checkNumberIsWithinInterval(number)
        </td>
      </tr><tr>
        <td>
          178
        </td>
        <td>
          778
        </td>
        <td>
          4874
          -
          4993
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          if (Puzzle.this.checkNumberIsWithinInterval(number))
  v
else
  false
        </td>
      </tr><tr>
        <td>
          179
        </td>
        <td>
          775
        </td>
        <td>
          4931
          -
          4932
        </td>
        <td>
          Ident
        </td>
        <td>
          Puzzle.v
        </td>
        <td style="background: #AEF1AE">
          v
        </td>
      </tr><tr>
        <td>
          181
        </td>
        <td>
          777
        </td>
        <td>
          4972
          -
          4977
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          false
        </td>
      </tr><tr>
        <td>
          181
        </td>
        <td>
          776
        </td>
        <td>
          4972
          -
          4977
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          false
        </td>
      </tr><tr>
        <td>
          184
        </td>
        <td>
          779
        </td>
        <td>
          5031
          -
          5036
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #F0ADAD">
          false
        </td>
      </tr><tr>
        <td>
          186
        </td>
        <td>
          781
        </td>
        <td>
          4619
          -
          5087
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td style="background: #AEF1AE">
          line.foldLeft[Boolean](valid)(((x0$8: Boolean, x1$8: Option[Int]) =&gt; scala.Tuple2.apply[Boolean, Option[Int]](x0$8, x1$8) match {
  case (_1: Boolean, _2: Option[Int])(Boolean, Option[Int])((v @ _), (numberOpt @ _)) =&gt; numberOpt match {
    case (x: Int)Some[Int]((number @ _)) =&gt; {
      val count: Int = line.filter(((numb: Option[Int]) =&gt; numberOpt.==(numb))).size;
      if (count.&gt;(1))
        false
      else
        if (Puzzle.this.checkNumberIsWithinInterval(number))
          v
        else
          false
    }
    case scala.None =&gt; false
  }
})).&amp;&amp;(line.length.==(Puzzle.this.sizeFromString))
        </td>
      </tr><tr>
        <td>
          186
        </td>
        <td>
          780
        </td>
        <td>
          5058
          -
          5087
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td style="background: #AEF1AE">
          line.length.==(Puzzle.this.sizeFromString)
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          783
        </td>
        <td>
          5291
          -
          5319
        </td>
        <td>
          Apply
        </td>
        <td>
          Puzzle.validateSquares
        </td>
        <td style="background: #AEF1AE">
          Puzzle.this.validateSquares(puzzleBoard)
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          782
        </td>
        <td>
          5259
          -
          5287
        </td>
        <td>
          Apply
        </td>
        <td>
          Puzzle.validateColumns
        </td>
        <td style="background: #AEF1AE">
          Puzzle.this.validateColumns(puzzleBoard)
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          785
        </td>
        <td>
          5230
          -
          5356
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td style="background: #AEF1AE">
          Puzzle.this.validateRows(puzzleBoard).&amp;&amp;(Puzzle.this.validateColumns(puzzleBoard)).&amp;&amp;(Puzzle.this.validateSquares(puzzleBoard)).&amp;&amp;(Puzzle.this.validateInputNumbers(puzzleBoard))
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          784
        </td>
        <td>
          5323
          -
          5356
        </td>
        <td>
          Apply
        </td>
        <td>
          Puzzle.validateInputNumbers
        </td>
        <td style="background: #AEF1AE">
          Puzzle.this.validateInputNumbers(puzzleBoard)
        </td>
      </tr><tr>
        <td>
          197
        </td>
        <td>
          786
        </td>
        <td>
          5463
          -
          5467
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          true
        </td>
      </tr><tr>
        <td>
          197
        </td>
        <td>
          788
        </td>
        <td>
          5442
          -
          5527
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.foldLeft
        </td>
        <td style="background: #AEF1AE">
          puzzleBoard.foldLeft[Boolean](true)(((x0$9: Boolean, x1$9: Seq[Option[Int]]) =&gt; scala.Tuple2.apply[Boolean, Seq[Option[Int]]](x0$9, x1$9) match {
  case (_1: Boolean, _2: Seq[Option[Int]])(Boolean, Seq[Option[Int]])((valid @ _), (row @ _)) =&gt; Puzzle.this.validateLine(row, valid)
}))
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          787
        </td>
        <td>
          5497
          -
          5521
        </td>
        <td>
          Apply
        </td>
        <td>
          Puzzle.validateLine
        </td>
        <td style="background: #AEF1AE">
          Puzzle.this.validateLine(row, valid)
        </td>
      </tr><tr>
        <td>
          203
        </td>
        <td>
          789
        </td>
        <td>
          5640
          -
          5677
        </td>
        <td>
          Apply
        </td>
        <td>
          Puzzle.boardMapToColumns
        </td>
        <td style="background: #AEF1AE">
          Puzzle.boardMapToColumns(puzzleBoard)
        </td>
      </tr><tr>
        <td>
          204
        </td>
        <td>
          792
        </td>
        <td>
          5682
          -
          5790
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.foldLeft
        </td>
        <td style="background: #AEF1AE">
          boardMapInColumns.foldLeft[Boolean](true)(((x0$10: Boolean, x1$10: (Int, Seq[Option[Int]])) =&gt; scala.Tuple2.apply[Boolean, (Int, Seq[Option[Int]])](x0$10, x1$10) match {
  case (_1: Boolean, _2: (Int, Seq[Option[Int]]))(Boolean, (Int, Seq[Option[Int]]))((valid @ _), (_1: Int, _2: Seq[Option[Int]])(Int, Seq[Option[Int]])((cindex @ _), (column @ _))) =&gt; Puzzle.this.validateLine(column, valid)
}))
        </td>
      </tr><tr>
        <td>
          204
        </td>
        <td>
          790
        </td>
        <td>
          5709
          -
          5713
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          true
        </td>
      </tr><tr>
        <td>
          205
        </td>
        <td>
          791
        </td>
        <td>
          5757
          -
          5784
        </td>
        <td>
          Apply
        </td>
        <td>
          Puzzle.validateLine
        </td>
        <td style="background: #AEF1AE">
          Puzzle.this.validateLine(column, valid)
        </td>
      </tr><tr>
        <td>
          210
        </td>
        <td>
          793
        </td>
        <td>
          5893
          -
          5930
        </td>
        <td>
          Apply
        </td>
        <td>
          Puzzle.boardMapToSquares
        </td>
        <td style="background: #AEF1AE">
          Puzzle.boardMapToSquares(puzzleBoard)
        </td>
      </tr><tr>
        <td>
          211
        </td>
        <td>
          794
        </td>
        <td>
          5952
          -
          5956
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          true
        </td>
      </tr><tr>
        <td>
          211
        </td>
        <td>
          796
        </td>
        <td>
          5935
          -
          6033
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.foldLeft
        </td>
        <td style="background: #AEF1AE">
          squares.foldLeft[Boolean](true)(((x0$11: Boolean, x1$11: ((Int, Int), Seq[Option[Int]])) =&gt; scala.Tuple2.apply[Boolean, ((Int, Int), Seq[Option[Int]])](x0$11, x1$11) match {
  case (_1: Boolean, _2: ((Int, Int), Seq[Option[Int]]))(Boolean, ((Int, Int), Seq[Option[Int]]))((valid @ _), (_1: (Int, Int), _2: Seq[Option[Int]])((Int, Int), Seq[Option[Int]])((cindex @ _), (column @ _))) =&gt; Puzzle.this.validateLine(column, valid)
}))
        </td>
      </tr><tr>
        <td>
          212
        </td>
        <td>
          795
        </td>
        <td>
          6000
          -
          6027
        </td>
        <td>
          Apply
        </td>
        <td>
          Puzzle.validateLine
        </td>
        <td style="background: #AEF1AE">
          Puzzle.this.validateLine(column, valid)
        </td>
      </tr><tr>
        <td>
          217
        </td>
        <td>
          797
        </td>
        <td>
          6145
          -
          6189
        </td>
        <td>
          Apply
        </td>
        <td>
          Puzzle.boardMapToRowsAndColumns
        </td>
        <td style="background: #AEF1AE">
          Puzzle.boardMapToRowsAndColumns(puzzleBoard)
        </td>
      </tr><tr>
        <td>
          218
        </td>
        <td>
          799
        </td>
        <td>
          6212
          -
          6250
        </td>
        <td>
          Apply
        </td>
        <td>
          Puzzle.boardMapToRowsAndColumns
        </td>
        <td style="background: #AEF1AE">
          Puzzle.boardMapToRowsAndColumns(Puzzle.this.board)
        </td>
      </tr><tr>
        <td>
          218
        </td>
        <td>
          798
        </td>
        <td>
          6244
          -
          6249
        </td>
        <td>
          Select
        </td>
        <td>
          Puzzle.board
        </td>
        <td style="background: #AEF1AE">
          Puzzle.this.board
        </td>
      </tr><tr>
        <td>
          219
        </td>
        <td>
          800
        </td>
        <td>
          6281
          -
          6285
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          true
        </td>
      </tr><tr>
        <td>
          219
        </td>
        <td>
          814
        </td>
        <td>
          6255
          -
          6636
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.foldLeft
        </td>
        <td style="background: #AEF1AE">
          solutionMap.keys.foldLeft[Boolean](true)(((x0$12: Boolean, x1$12: (Int, Int)) =&gt; scala.Tuple2.apply[Boolean, (Int, Int)](x0$12, x1$12) match {
  case (_1: Boolean, _2: (Int, Int))(Boolean, (Int, Int))((valid @ _), (_1: Int, _2: Int)(Int, Int)((rindex @ _), (cindex @ _))) =&gt; {
    val originalVal: Option[Int] = originalMap.getOrElse[Option[Int]](scala.Tuple2.apply[Int, Int](rindex, cindex), scala.None);
    if (originalVal.nonEmpty)
      {
        val solutionVal: Option[Int] = solutionMap.getOrElse[Option[Int]](scala.Tuple2.apply[Int, Int](rindex, cindex), scala.None);
        if (solutionVal.==(originalVal))
          valid
        else
          false
      }
    else
      valid
  }
}))
        </td>
      </tr><tr>
        <td>
          220
        </td>
        <td>
          801
        </td>
        <td>
          6369
          -
          6384
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Int, Int](rindex, cindex)
        </td>
      </tr><tr>
        <td>
          220
        </td>
        <td>
          803
        </td>
        <td>
          6347
          -
          6391
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.MapLike.getOrElse
        </td>
        <td style="background: #AEF1AE">
          originalMap.getOrElse[Option[Int]](scala.Tuple2.apply[Int, Int](rindex, cindex), scala.None)
        </td>
      </tr><tr>
        <td>
          220
        </td>
        <td>
          802
        </td>
        <td>
          6386
          -
          6390
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          221
        </td>
        <td>
          804
        </td>
        <td>
          6401
          -
          6421
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Option.nonEmpty
        </td>
        <td style="background: #AEF1AE">
          originalVal.nonEmpty
        </td>
      </tr><tr>
        <td>
          221
        </td>
        <td>
          812
        </td>
        <td>
          6422
          -
          6601
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          {
  val solutionVal: Option[Int] = solutionMap.getOrElse[Option[Int]](scala.Tuple2.apply[Int, Int](rindex, cindex), scala.None);
  if (solutionVal.==(originalVal))
    valid
  else
    false
}
        </td>
      </tr><tr>
        <td>
          222
        </td>
        <td>
          806
        </td>
        <td>
          6489
          -
          6493
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          222
        </td>
        <td>
          805
        </td>
        <td>
          6472
          -
          6487
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Int, Int](rindex, cindex)
        </td>
      </tr><tr>
        <td>
          222
        </td>
        <td>
          807
        </td>
        <td>
          6450
          -
          6494
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.MapLike.getOrElse
        </td>
        <td style="background: #AEF1AE">
          solutionMap.getOrElse[Option[Int]](scala.Tuple2.apply[Int, Int](rindex, cindex), scala.None)
        </td>
      </tr><tr>
        <td>
          223
        </td>
        <td>
          808
        </td>
        <td>
          6506
          -
          6532
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td style="background: #AEF1AE">
          solutionVal.==(originalVal)
        </td>
      </tr><tr>
        <td>
          224
        </td>
        <td>
          809
        </td>
        <td>
          6545
          -
          6550
        </td>
        <td>
          Ident
        </td>
        <td>
          Puzzle.valid
        </td>
        <td style="background: #AEF1AE">
          valid
        </td>
      </tr><tr>
        <td>
          226
        </td>
        <td>
          810
        </td>
        <td>
          6578
          -
          6583
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          false
        </td>
      </tr><tr>
        <td>
          226
        </td>
        <td>
          811
        </td>
        <td>
          6578
          -
          6583
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td style="background: #AEF1AE">
          false
        </td>
      </tr><tr>
        <td>
          229
        </td>
        <td>
          813
        </td>
        <td>
          6617
          -
          6622
        </td>
        <td>
          Ident
        </td>
        <td>
          Puzzle.valid
        </td>
        <td style="background: #AEF1AE">
          valid
        </td>
      </tr>
    </table>
          </div>
        </div>
      </body>
    </html>